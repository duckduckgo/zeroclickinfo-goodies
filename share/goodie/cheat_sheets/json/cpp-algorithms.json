{
    "id": "cpp_algorithms_cheat_sheet",
    "name": "C++ Algorithms",
    "description": "C++ <algorithm> library reference. This library provides a variety of different functions e.g. paritions, sorting, searching, merging, heap and min/max algorithms which operate on ranges of elements.",
    "metadata": {
        "sourceName": "cplusplus",
        "sourceUrl": "http://www.cplusplus.com/reference/algorithm/"
    },
    "template_type": "terminal",
    "aliases": [
        "c++ algorithms",
        "cpp algorithm",
        "c++ algorithm",
        "cpp algo",
        "c++ algo"
    ],
    "section_order": [
        "Non-Modifying sequence operations",
        "Modifying sequence operations",
        "Partitions",
        "Sorting",
        "Binary search",
        "Merge",
        "Heap",
        "Min/Max",
        "Other"
    ],
    "sections": {
        "Non-Modifying sequence operations": [
            {
                "key": "all_of (foo.begin(), foo.end(), pred)",
                "val": "Returns true if pred returns true for all the elements in the range or if the range is empty"
            },
            {
                "key": "any_of (foo.begin(), foo.end(), pred)",
                "val": "Returns true if pred returns true for any of the elements in the range"
            },
            {
                "key": "none_of (foo.begin(), foo.end(), pred)",
                "val": "Returns true if pred returns false for all the elements in the range"
            },
            {
                "key": "for_each (foo.begin(), foo.end(), fn)",
                "val": "Apply function to range"
            },
            {
                "key": "find (foo.begin(), foo.end(), const T& val)",
                "val": "Find value in range"
            },
            {
                "key": "find_if (foo.begin(), foo.end(), pred)",
                "val": "Returns an iterator to the first element in the range for which pred returns true"
            },
            {
                "key": "find_if_not (foo.begin(), foo.end(), pred)",
                "val": "Returns an iterator to the first element in the range for which pred returns false."
            },
            {
                "key": "find_end (foo.begin(), foo.end(), bar.begin(), bar.end())",
                "val": "Searches the foo range for the last occurrence of the sequence defined by bar range, and returns an iterator to its first element"
            },
            {
                "key": "find_first_of (foo.begin(), foo.end(), bar.begin(), bar.end())",
                "val": "Returns an iterator to the first element in the foo range that matches any of the elements in bar range"
            },
            {
                "key": "adjacent_find (foo.begin(), foo.end())",
                "val": "Find equal adjacent elements in range"
            },
            {
                "key": "count (foo.begin(), foo.end(), const T& val)",
                "val": "Count appearances of value in range"
            },
            {
                "key": "count_if (foo.begin(), foo.end(), pred)",
                "val": "Returns the number of elements in the range for which pred is true"
            },
            {
                "key": "mismatch (foo.begin(), foo.end(), bar.begin())",
                "val": "Return first position where two ranges differ"
            },
            {
                "key": "equal (foo.begin(), foo.end(), bar.begin())",
                "val": "Test whether the elements in two ranges are equal"
            },
            {
                "key": "is_permutation (foo.begin(), foo.end(), bar.begin())",
                "val": "Test whether range1 is permutation of another"
            },
            {
                "key": "search (foo.begin(), foo.end(), bar.begin(), bar.end())",
                "val": "Searches the range1 for the first occurrence of the sequence defined by range2, and returns an iterator to its first element"
            },
            {
                "key": "search_n (foo.begin(), foo.end(), Size count, const T& val)",
                "val": "Searches the range1 for a sequence of count elements, each comparing equal to val"
            }
        ],
        "Modifying sequence operations": [
            {
                "key": "copy (foo.begin(), foo.end(), result)",
                "val": "Copy range of elements"
            },
            {
                "key": "copy_n (foo.begin(), Size n, result)",
                "val": "Copies the first n elements from the range beginning at foo.begin() into the range beginning at result"
            },
            {
                "key": "copy_if (foo.begin(), foo.end(), result, pred)",
                "val": "Copies the elements in the range for which pred returns true to the range beginning at result"
            },
            {
                "key": "copy_backward (foo.begin(), foo.end(), result)",
                "val": "Copies the elements in the range starting backward into the range terminating at result"
            },
            {
                "key": "move (foo.begin(), foo.end(), result)",
                "val": "Moves the elements in the range1 into the range beginning at resulâ€‹t"
            },
            {
                "key": "move_backward (foo.begin(), foo.end(), result)",
                "val": "Move range of elements backward"
            },
            {
                "key": "swap (T& a, T& b)",
                "val": "Exchange values of two objects"
            },
            {
                "key": "swap_ranges (foo.begin(), foo.end(), bar.begin())",
                "val": "Exchange values of two ranges"
            },
            {
                "key": "iter_swap (a, b)",
                "val": "Exchange values of objects pointed to by two iterators"
            },
            {
                "key": "transform (foo.begin(), foo.end(), result, op)",
                "val": "Applies op to each of the elements in the range and stores the value returned by each operation in the range that begins at result."
            },
            {
                "key": "replace (foo.begin(), foo.end(), const T& old_value, const T& new_value)",
                "val": "Replace value in range"
            },
            {
                "key": "replace_if (foo.begin(), foo.end(), pred, const T& new_value )",
                "val": "Replace values in range for which pred returns true"
            },
            {
                "key": "replace_copy (foo.begin(), foo.end(), result, const T& old_value, const T& new_value)",
                "val": "Copy range replacing value"
            },
            {
                "key": "replace_copy_if (foo.begin(), foo.end(), result, pred, const T& new_value)",
                "val": "Copy range replacing value for which pred returns true"
            },
            {
                "key": "fill (foo.begin(), foo.end(), const T& val)",
                "val": "Fill range with value"
            },
            {
                "key": "fill_n (foo.begin(), Size n, const T& val)",
                "val": "Fill sequence with value"
            },
            {
                "key": "generate (foo.begin(), foo.end(), gen)",
                "val": "Generate values for range with function"
            },
            {
                "key": "generate_n (foo.begin(), Size n, gen)",
                "val": "Generate values for sequence with function"
            },
            {
                "key": "remove (foo.begin(), foo.end(), const T& val)",
                "val": "Remove value from range"
            },
            {
                "key": "remove_if (foo.begin(), foo.end(), pred)",
                "val": "Remove elements from range for which pred returns true"
            },
            {
                "key": "remove_copy (foo.begin(), foo.end(), result, const T& val)",
                "val": "Copy range removing value"
            },
            {
                "key": "remove_copy_if (foo.begin(), foo.end(), result, pred)",
                "val": "Copy range removing values for which pred returns true"
            },
            {
                "key": "unique (foo.begin(), foo.end())",
                "val": "Remove consecutive duplicates in range"
            },
            {
                "key": "unique_copy (foo.begin(), foo.end(), result)",
                "val": "Copy range removing duplicates"
            },
            {
                "key": "reverse (foo.begin(), foo.end())",
                "val": "reverse range"
            },
            {
                "key": "reverse_copy (foo.begin(), foo.end(), result)",
                "val": "Copy range replacing value"
            },
            {
                "key": "rotate (foo.begin(), middle, foo.end())",
                "val": "Rotate left the elements in range"
            },
            {
                "key": "rotate_copy (foo.begin(), middle, foo.end(), result)",
                "val": "Copy range rotated left"
            },
            {
                "key": "random_shuffle (foo.begin(), foo.end())",
                "val": "Randomly rearrange elements in range"
            },
            {
                "key": "shuffle (foo.begin(), foo.end(), URNG&& g)",
                "val": "Randomly rearrange elements in range using generator"
            }
        ],
        "Partitions": [
            {
                "key": "is_partitioned (foo.begin(), foo.end(), pred)",
                "val": "Test whether range is partitioned"
            },
            {
                "key": "partition (foo.begin(), foo.end(), pred)",
                "val": "Partition range in two"
            },
            {
                "key": "stable_partition (foo.begin(), foo.end(), pred)",
                "val": "Partition range in two - stable ordering"
            },
            {
                "key": "partition_copy (foo.begin(), foo.end(), result_true, result_false, pred)",
                "val": "Copies the elements in the range for which pred returns true into the range pointed by result_true, and else to the range pointed by result_false"
            },
            {
                "key": "partition_point (foo.begin(), foo.end(), pred)",
                "val": "Get partition point"
            }
        ],
        "Sorting": [
            {
                "key": "sort (foo.begin(), foo.end())",
                "val": "Sort elements in range"
            },
            {
                "key": "stable_sort (foo.begin(), foo.end())",
                "val": "Sort elements preserving order of equivalents"
            },
            {
                "key": "partial_sort (foo.begin(), middle, foo.end())",
                "val": "Partially sort elements in range in such a way that the elements before middle(random access iterator) are the smallest elements in the entire range"
            },
            {
                "key": "partial_sort_copy (foo.begin(), foo.end(), result_first, result_last)",
                "val": "Copy and partially sort range"
            },
            {
                "key": "is_sorted_until (foo.begin(), foo.end())",
                "val": "Check whether range is sorted"
            },
            {
                "key": "nth_element (foo.begin(), nth, foo.end())",
                "val": "Rearranges the elements in the range, in such a way that the element at the nth position(random access iterator) is the element that would be in that position in a sorted sequence"
            }
        ],
        "Binary search": [
            {
                "key": "lower_bound (foo.begin(), foo.end(), const T& val)",
                "val": "Return iterator to lower bound"
            },
            {
                "key": "upper_bound (foo.begin(), foo.end(), const T& val)",
                "val": "Return iterator to upper bound"
            },
            {
                "key": "equal_range (foo.begin(), foo.end(), const T& val)",
                "val": "Get subrange of equal elements"
            },
            {
                "key": "binary_search (foo.begin(), foo.end(), const T& val)",
                "val": "Test if value exists in sorted sequence"
            }
        ],
        "Merge": [
            {
                "key": "merge (foo.begin(), foo.end(), bar.begin(), bar.end(), result)",
                "val": "Merge sorted ranges"
            },
            {
                "key": "inplace_merge (foo.begin(), middle, foo.end())",
                "val": "Merge consecutive sorted ranges, here middle is a bidirectional iterator"
            },
            {
                "key": "includes (foo.begin(), foo.end(), bar.begin(), bar.end() )",
                "val": "Test whether sorted range includes another sorted range"
            },
            {
                "key": "set_union (foo.begin(), foo.end(), bar.begin(), bar.end(), result)",
                "val": "Union of two sorted ranges"
            },
            {
                "key": "set_intersection (foo.begin(), foo.end(), bar.begin(), bar.end(), result)",
                "val": "Intersection of two sorted ranges"
            },
            {
                "key": "set_difference (foo.begin(), foo.end(), bar.begin(), bar.end(), result)",
                "val": "Difference of two sorted ranges"
            },
            {
                "key": "set_symmetric_difference (foo.begin(), foo.end(), bar.begin(), bar.end(), result)",
                "val": "Symmetric difference of two sorted ranges"
            }
        ],
        "Heap": [
            {
                "key": "push_heap (foo.begin(), foo.end())",
                "val": "Push element into heap range"
            },
            {
                "key": "pop_heap (foo.begin(), foo.end())",
                "val": "Pop element from heap range"
            },
            {
                "key": "make_heap (foo.begin(), foo.end())",
                "val": "Make heap from range"
            },
            {
                "key": "sort_heap (foo.begin(), foo.end())",
                "val": "Sort elements of heap"
            },
            {
                "key": "is_heap (foo.begin(), foo.end())",
                "val": "Test if range is heap"
            },
            {
                "key": "is_heap_until (foo.begin(), foo.end())",
                "val": "Find foo.begin() element not in heap order"
            }
        ],
        "Min/Max": [
            {
                "key": "min (const T& a, const T& b)",
                "val": "Return the smallest"
            },
            {
                "key": "max (const T& a, const T& b)",
                "val": "Return the largest"
            },
            {
                "key": "minmax (const T& a, const T& b)",
                "val": "Return smallest and largest elements"
            },
            {
                "key": "min_element (foo.begin(), foo.end())",
                "val": "Return smallest element in range"
            },
            {
                "key": "max_element (foo.begin(), foo.end())",
                "val": "Return largest element in range"
            },
            {
                "key": "minmax_element (foo.begin(), foo.end())",
                "val": "Return smallest and largest elements in range"
            }
        ],
        "Other": [
            {
                "key": "lexicographical_compare (foo.begin(), foo.end(), bar.begin(), bar.end())",
                "val": "Lexicographical less-than comparison"
            },
            {
                "key": "next_permutation (foo.begin(), foo.end())",
                "val": "Transform range to next permutation"
            },
            {
                "key": "prev_permutation (foo.begin(), foo.end(), comp)",
                "val": "Transform range to previous permutation"
            }
        ]
    }
}
